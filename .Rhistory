endTime =  endTime,
ice = FALSE,
Hi = 0,
iceT = 6,
supercooled = 0,
kd_light = 0.5,
sw_factor = 1.0,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo,
Cd = 0.0013,
scheme = 'implicit')
## SAVE THE RESULTS
temp = res$temp
mixing = res$mixing
ice = res$icethickness
avgtemp = res$average
## POST-PROCESSING OF THE RESULTS
time =  startingDate + seq(1, ncol(temp), 1) * dt
avgtemp = as.data.frame(avgtemp)
colnames(avgtemp) = c('time', 'epi', 'hyp', 'tot', 'stratFlag', 'thermoclineDep')
avgtemp$time = time
## AVERAGE TEMPERATURES IN EPILIMNION AND HYPOLIMNION
ggplot(avgtemp) +
geom_line(aes(time, epi, col = 'epilimnion')) +
geom_line(aes(time, hyp, col = 'hypolimnion')) +
geom_line(aes(time, tot, col = 'total')) +
theme_minimal()
## CREATE DATAFRAME FOR FULL TEMPERATURE PROFILES
df <- data.frame(cbind(time, t(temp)) )
colnames(df) <- c("time", as.character(paste0(seq(1,nrow(temp)))))
m.df <- reshape2::melt(df, "time")
m.df$time <- time
## CREATE DATAFRAME FOR ICE
df.ice = data.frame('time' = time,
'ice_h' = ice)
## HEATMAP OF WATER TEMPERATURE WITH THERMOCLINE DEPTH AND ICE THICKNESS
ggplot(m.df, aes((time), dx*as.numeric(as.character(variable)))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(limits = c(-1,30),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth [m]') +
labs(fill = 'Temp [degC]')+
geom_line(data = avgtemp, aes(time, thermoclineDep, col = 'thermocline depth'), linetype = 'dashed', col = 'brown') +
geom_line(data = df.ice, aes(time, ice_h * (-1), col = 'ice thickness'), linetype = 'solid', col = 'darkblue') +
scale_y_reverse()
setwd('../lake_trophic_status/')
setwd('../lake_trophic_status/')
item = 1
n = 5
x = 0
while(item <= n){
x <- x + item
item = item + 1
}
print(x)
time = 100
space = 100
conc >- matrix(0, nrow = space, ncol = time)
time = 100
space = 100
conc <- matrix(0, nrow = space, ncol = time)
K = 0.5
dx = 1
dt = 1
conc <- dnorm(seq(1,space,1), mean = 50, sd = 1) * 100
for (n in 2:ncol(conc)){
for (i in 2:(nrow(conc)-1)){
conc[i, n] = conc[i, n-1] +  K * dt/dx**2 * (conc[i-1, n-1] - 2 * conc[i, n-1] + conc[i+1, n-1])
}
}
time = 100
space = 100
conc <- matrix(0, nrow = space, ncol = time)
K = 0.5
dx = 1
dt = 1
conc[, 1] <- dnorm(seq(1,space,1), mean = 50, sd = 1) * 100
for (n in 2:ncol(conc)){
for (i in 2:(nrow(conc)-1)){
conc[i, n] = conc[i, n-1] +  K * dt/dx**2 * (conc[i-1, n-1] - 2 * conc[i, n-1] + conc[i+1, n-1])
}
}
conc
plot(conc[,1])
dev.off()
plot(conc[,1])
conc[,1]
time = 100
space = 100
conc <- matrix(0, nrow = space, ncol = time)
K = 0.5
dx = 1
dt = 1
conc[, 1] <- dnorm(seq(1,space,1), mean = 50, sd = 1) * 100
for (n in 2:ncol(conc)){
for (i in 2:(nrow(conc)-1)){
conc[i, n] = conc[i, n-1] +  K * dt/dx^2 * (conc[i-1, n-1] - 2 * conc[i, n-1] + conc[i+1, n-1])
}
}
plot(conc[,1])
plot(conc[,100])
plot(conc[,1])
plot(conc[,100])
time = paste0(seq(1,ncol(conc)))
df <- data.frame(cbind(time, t(conc)))
library(tidyverse)
library(reshape2)
colnames(df) <- c('time', as.cahracter(paste0(seq(1, nrow(conc))))
colnames(df) <- c('time', as.character(paste0(seq(1, nrow(conc))))
colnames(df) <- c('time', as.character(paste0(seq(1, nrow(conc))))
colnames(df) <- c('time', as.character(paste0(seq(1, nrow(conc))))
time = 100
space = 100
conc <- matrix(0, nrow = space, ncol = time)
K = 0.5
dx = 1
dt = 1
conc[, 1] <- dnorm(seq(1,space,1), mean = 50, sd = 1) * 100
for (n in 2:ncol(conc)){
for (i in 2:(nrow(conc)-1)){
conc[i, n] = conc[i, n-1] +  K * dt/dx^2 * (conc[i-1, n-1] - 2 * conc[i, n-1] + conc[i+1, n-1])
}
}
# Let's plot this!
library(tidyverse)
library(reshape2)
time =  paste0(seq(1,ncol(conc)))
df <- data.frame(cbind(time, t(conc)) )
colnames(df) <- c("time", as.character(paste0(seq(1,nrow(conc)))))
m.df <- reshape2::melt(df, "time")
m.df$time <- time
ggplot(m.df, aes(as.numeric(time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(limits = c(-1,100),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Conc. [%]')
remotes::install_github('eco4cast/neon4cast')
setwd("~/Projects/GLEON2022/EezyPeezyISIOxy")
library(tidyverse)
# dO2/dt = Flux * (O2 / (Khalf + O2)) * Theta^(Temp - 20) * Area
# g/day = g/m2/day  * m2
Output <- c(NULL)
for (k in 1:10){
# Normal distributions for parameter assumptions
Flux <- rnorm(1, mean = -0.32, sd = 0.096)  # (g / m2 / d)
Khalf <- rnorm(1, mean = 0.224, sd = 0.032)   # (g / m3)
Theta <- rnorm(1, mean = 1.07, sd = 0.03) # (-)
dt = 1
library(rLakeAnalyzer)
library(LakeMetabolizer)
Temp_raw <- read_delim('InputTest/temperate/output_temp.txt', skip = 8, delim = '\t')
str(Temp_raw)
head(Temp_raw)
Depth_raw <- read_delim('InputTest/temperate/output_z.txt', skip = 8, delim = '\t')
Depth <- as.numeric(Depth_raw[1, -1]) * (-1)
Area_raw <- read_delim('InputTest/temperate/hypsograph.dat', skip = 1, delim = ' ',
col_names = F)
Area_list = data.frame('Depth' = (Area_raw[, 1] - max(Area_raw[, 1])) * (-1), 'Area' = Area_raw[, 2])
Area_list = apply(Area_list, 2, rev)
Area_list <- as.data.frame(Area_list)
Temp <- Temp_raw
colnames(Temp) <- c('Datetime', paste0('wtr_', Depth))
Temp <- data.frame('datetime' = Temp$Datetime, rev(Temp[, 2:ncol(Temp)]))
head(Temp)
Temp <- Temp %>%
dplyr::filter(datetime >= as.POSIXct('2000-01-01') &
datetime <= as.POSIXct('2000-12-31'))
Stratification <- data.frame('Datetime' = Temp$datetime, 'Density.Diff' = water.density(Temp[, ncol(Temp)]) - water.density(Temp[, 2]))
Stratification$Stratif.Check <- ifelse(Stratification$Density.Diff >= 0.1, 1, NA)
ggplot(Stratification) + geom_line(aes(Datetime, Stratif.Check))
Strat.Period <- (na.contiguous(Stratification$Stratif.Check))
Temp <- Temp[attributes(Strat.Period)$tsp[1]:
attributes(Strat.Period)$tsp[2],]
Thermocline.depth <- ts.center.buoyancy(wtr = Temp)
str(Thermocline.depth)
ggplot(subset(Thermocline.depth, datetime > as.Date('2000-01-01') &
datetime < as.Date('2000-12-31')),
aes(datetime, cent.n2)) +
geom_path() +
geom_smooth() +
scale_y_reverse()
Thermocline.PK <- read.csv('InputTest/temperate/thermo_information.csv')
Strat.Period <- (na.contiguous(Thermocline.PK$stratified))
Thermocline.PK <- Thermocline.PK[attributes(Strat.Period)$tsp[1]:
attributes(Strat.Period)$tsp[2],]
Area_interp <- approx(Area_list$X1, Area_list$X2, seq(0, max(Area_list$X1), 0.1))$y
Area_interp <- data.frame('Depth' = seq(0, max(Area_list$X1), 0.1), 'Area' =
Area_interp)
Area_interp$Volume <- rev(cumsum(Area_interp$Depth * Area_interp$Area))
Volume <- approx(Area_interp$Depth, Area_interp$Volume, Thermocline.PK$thermocline_depth_smooth,
rule =2)$y # VOLUME FROM AREA DEPENDING ON THERMOCLINE DEPTH
Area <- approx(Area_interp$Depth, Area_interp$Area, Thermocline.PK$thermocline_depth_smooth,
rule = 2)$y # ACTIVE AREA FOR SEDIMENT FLUX
Temp <- Thermocline.PK$hypo_temp
Oxygen <- rep(NA, length(Volume))
Oxygen[1] <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
for (i in 2:length(Oxygen)){
Oxygen[i] <- (Oxygen[i - 1] +
Area[i - 1] * (Flux *
((Oxygen[i - 1]/ Volume[i -1 ]) / (Khalf + Oxygen[i - 1] / Volume[i - 1] )) *
Theta^(Temp[i-1] - 20)) * dt ) * Volume[i] / Volume[i-1]
}
Output <- cbind(Output, Oxygen / Volume)
}
Output_df = data.frame('Time' = Thermocline.PK$datetime, Output)
m.Output_df = pivot_longer(Output_df, 2:last_col())
m.Output_df <- m.Output_df %>%
mutate(Time = lubridate::as_datetime(Time))
ggplot(m.Output_df) +
geom_line(aes(Time, value, group = name)) +
theme_bw() + xlab('Date') + ylab('O2 [mg/L]') #+
# scale_x_datetime(date_labels = "%M-")
Time_linear <- seq(1, length(Temp), 1)
Time_linear <- seq(1, length(Temp), 1)
Area_linear <- approxfun(x = Time_linear, y = Area, method = "linear", rule = 2)
Volume_linear <- approxfun(x = Time_linear, y = Volume, method = "linear", rule = 2)
Temp_linear <- approxfun(x = Time_linear, y = Temp, method = "linear", rule = 2)
# Model code
o2_model <- function(t, y, parms){
dO2 <- (y +
Area(t) * (Flux *
((y/ Volume(t)) / (Khalf + y/ Volume(t))) *
Theta^(Temp(t) - 20)) * dt ) * Volume(t) / Volume(t-1)
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
ode(times = times, y = yini, func = o2_model, parms = parameters, method = 'rk4')
?ode
??ode
library(deSolve)
# Runge-Kutta 4th-order model solver
ode(times = times, y = yini, func = o2_model, parms = parameters, method = 'rk4')
# Runge-Kutta 4th-order model solver
ode(times = Time_linear, y = yini, func = o2_model, parms = parameters, method = 'rk4')
# Model code
o2_model <- function(t, y, parms){
dO2 <- (y +
Area_linear(t) * (Flux *
((y/ Volume(t)) / (Khalf + y/ Volume_linear(t))) *
Theta^(Temp_linear(t) - 20)) * dt ) * Volume_linear(t) / Volume_linear(t-1)
}
# Runge-Kutta 4th-order model solver
ode(times = Time_linear, y = yini, func = o2_model, parms = parameters, method = 'rk4')
# Model code
o2_model <- function(t, y, parms){
dO2 <- (y +
Area_linear(t) * (Flux *
((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
Theta^(Temp_linear(t) - 20)) * dt ) * Volume_linear(t) / Volume_linear(t-1)
}
# Runge-Kutta 4th-order model solver
ode(times = Time_linear, y = yini, func = o2_model, parms = parameters, method = 'rk4')
# Model code
o2_model <- function(t, y, parms){
dO2 <- (y +
Area_linear(t) * (Flux *
((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
Theta^(Temp_linear(t) - 20)) * dt ) * Volume_linear(t) / Volume_linear(t-1)
return(dO2)
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
ode(times = Time_linear, y = yini, func = o2_model, parms = parameters, method = 'rk4')
# Model code
o2_model <- function(t, y, parms){
dO2 <- (y +
Area_linear(t) * (Flux *
((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
Theta^(Temp_linear(t) - 20)) * dt ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
ode(times = Time_linear, y = yini, func = o2_model, parms = parameters, method = 'rk4')
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model, parms = parameters, method = 'rk4')
plot(Output_ode/Volume)
Output_ode/Volume
plot(Output_ode[, 2/Volume)
plot(Output_ode[, 2]/Volume)
Output_ode[, 2]/Volume
Time_linear
# Model code
o2_model <- function(t, y, parms){
dO2 <- (y +
Area_linear(t) * (Flux *
((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
Theta^(Temp_linear(t) - 20)) ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
Area_linear
plot(Area_linear(Time_linear))
plot(Area)
plot(Area_linear(Time_linear))
plot(Volume_linear(Time_linear))
plot(Volume)
plot(Temp_linear(Time_linear))
plot(Temp)
# Model code
o2_model <- function(t, y, parms){
dO2 <- (y +
Area_linear(t) * (Flux *
((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
Theta^(Temp_linear(t) - 20)) ) #* Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
# Model code
o2_model <- function(t, y, parms){
dO2 <- y
# (y +
#         Area_linear(t) * (Flux *
#     ((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
#     Theta^(Temp_linear(t) - 20)) ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
Output_ode[, 2]/Volume
Output_ode
yini
yini/Volume[¹]
yini/Volume[1]
# Model code
o2_model <- function(t, y, parms){
dO2 <- y
# (y +
#         Area_linear(t) * (Flux *
#     ((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
#     Theta^(Temp_linear(t) - 20)) ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
Time_linear
parameters
yini
Time_linear
# Model code
o2_model <- function(t, y, parms){
dO2 <- y[1]
# (y +
#         Area_linear(t) * (Flux *
#     ((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
#     Theta^(Temp_linear(t) - 20)) ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
# Model code
o2_model <- function(t, y, parms){
dO2 <- 10
# (y +
#         Area_linear(t) * (Flux *
#     ((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
#     Theta^(Temp_linear(t) - 20)) ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
# Model code
o2_model <- function(t, y, parms){
dO2 <- NA
# (y +
#         Area_linear(t) * (Flux *
#     ((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
#     Theta^(Temp_linear(t) - 20)) ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
# Model code
o2_model <- function(t, y, parms){
dO2 <- (Area_linear(t) * (Flux *
((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
Theta^(Temp_linear(t) - 20)) ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
# Model code
o2_model <- function(t, y, parms){
dO2 <- (Area_linear(t) * (Flux *
((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
Theta^(Temp_linear(t) - 20)) ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
# Model code
o2_model <- function(t, y, parms){
dO2 <- (Area_linear(t) * (Flux *
((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
Theta^(Temp_linear(t) - 20)) )# * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
# Model code
o2_model <- function(t, y, parms){
dO2 <- Flux
# (Area_linear(t) * (Flux *
#     ((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
#     Theta^(Temp_linear(t) - 20)) ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
# Model code
o2_model <- function(t, y, parms){
dO2 <- 5
# (Area_linear(t) * (Flux *
#     ((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
#     Theta^(Temp_linear(t) - 20)) ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
# Model code
o2_model <- function(t, y, parms){
dO2 <- Khalf
# (Area_linear(t) * (Flux *
#     ((y/ Volume_linear(t)) / (Khalf + y/ Volume_linear(t))) *
#     Theta^(Temp_linear(t) - 20)) ) * Volume_linear(t) / Volume_linear(t-1)
return(list(dO2))
}
# Define parameters for model
parameters <- c(Flux, Khalf, Theta)
yini <- o2.at.sat.base(temp = Temp[1], altitude = 500) * Volume[1] # g
# Runge-Kutta 4th-order model solver
Output_ode <- ode(times = Time_linear, y = yini, func = o2_model,
parms = parameters, method = 'rk4')
plot(Output_ode[, 2]/Volume)
Output_ode
